<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-tw"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://otoitsuki.github.io/blog_videcoding50days/feed.xml" rel="self" type="application/atom+xml"/><link href="https://otoitsuki.github.io/blog_videcoding50days/" rel="alternate" type="text/html" hreflang="zh-tw"/><updated>2025-11-27T03:39:58+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/feed.xml</id><title type="html">blank</title><subtitle>10 年軟體規劃與設計經驗，擁有產品思維與設計思考能力的 Vide Coder。分享軟體開發、產品設計與技術思考。 </subtitle><entry><title type="html">a post with plotly.js</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/plotly/" rel="alternate" type="text/html" title="a post with plotly.js"/><published>2025-03-26T14:24:00+00:00</published><updated>2025-03-26T14:24:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/plotly</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/plotly/"><![CDATA[<p>This is an example post with some <a href="https://plotly.com/javascript/">plotly</a> code.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>Which generates:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "type": "scatter"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [16, 5, 11, 9],
      "type": "scatter"
    }
  ]
}
</code></pre> <p>Also another example chart.</p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">```</span><span class="nl">plotly
</span><span class="sb">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}</span>
<span class="p">```</span>
</code></pre></div></div> <p>This is how it looks like:</p> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}
</code></pre>]]></content><author><name></name></author><category term="sample-posts"/><category term="formatting"/><category term="charts"/><summary type="html"><![CDATA[this is what included plotly.js code could look like]]></summary></entry><entry><title type="html">Cursor vs Gemini vs Claude：開發者的 AI 工具選擇難題</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/ai-coding-tools-comparison/" rel="alternate" type="text/html" title="Cursor vs Gemini vs Claude：開發者的 AI 工具選擇難題"/><published>2025-01-15T10:00:00+00:00</published><updated>2025-01-15T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/ai-coding-tools-comparison</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/ai-coding-tools-comparison/"><![CDATA[<p>最近一直在糾結一個問題：明年到底要買 Cursor + Gemini + Claude，還是要做割捨省點錢？</p> <p>作為一個有 10 年軟體規劃與設計經驗的開發者，我深知工具的重要性，但同時也要考慮成本效益。</p> <h2 id="我的使用場景">我的使用場景</h2> <ul> <li><strong>Cursor</strong>：日常開發的主力 IDE，AI 輔助編碼非常順手</li> <li><strong>Gemini</strong>：Google 的 AI 模型，在某些任務上表現出色</li> <li><strong>Claude</strong>：Anthropic 的模型，在長文本處理和邏輯推理上很強</li> </ul> <h2 id="成本考量">成本考量</h2> <p>三個工具加起來的訂閱費用確實不低，但每個工具都有其獨特的價值。該如何取捨？</p> <h2 id="下一步">下一步</h2> <p>我會繼續測試和比較這些工具，找出最適合我工作流程的組合。也許可以採用「主力 + 備用」的策略？</p> <hr/> <p><em>這是我 50 天寫作挑戰的第一篇文章。</em></p>]]></content><author><name></name></author><category term="technology"/><category term="ai-tools"/><category term="productivity"/><category term="coding"/><summary type="html"><![CDATA[作為一個有 10 年經驗的開發者，我最近在思考明年到底要買 Cursor + Gemini + Claude，還是要做割捨省點錢。這篇文章記錄了我的思考過程。]]></summary></entry><entry><title type="html">產品思維如何改變我的開發方式</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/product-thinking-in-development/" rel="alternate" type="text/html" title="產品思維如何改變我的開發方式"/><published>2025-01-14T10:00:00+00:00</published><updated>2025-01-14T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/product-thinking-in-development</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/product-thinking-in-development/"><![CDATA[<p>在軟體開發這條路上走了 10 年，我發現最大的轉變不是技術能力的提升，而是思維方式的改變。</p> <h2 id="從能跑到好用">從「能跑」到「好用」</h2> <p>早期寫程式時，我的目標很簡單：讓程式能跑起來。但隨著經驗累積，我開始思考：</p> <ul> <li>這個功能真的解決了使用者的問題嗎？</li> <li>使用者會怎麼使用這個功能？</li> <li>有沒有更好的方式來呈現這個功能？</li> </ul> <h2 id="產品思維的三個層次">產品思維的三個層次</h2> <ol> <li><strong>功能層</strong>：這個功能能做什麼？</li> <li><strong>體驗層</strong>：使用者會怎麼感受這個功能？</li> <li><strong>價值層</strong>：這個功能創造了什麼價值？</li> </ol> <h2 id="設計思考的實踐">設計思考的實踐</h2> <p>設計思考不是設計師的專利，開發者同樣需要：</p> <ul> <li><strong>同理心</strong>：站在使用者角度思考</li> <li><strong>定義問題</strong>：釐清真正的需求</li> <li><strong>發想方案</strong>：探索各種可能性</li> <li><strong>原型製作</strong>：快速驗證想法</li> <li><strong>測試迭代</strong>：持續改進</li> </ul> <h2 id="結語">結語</h2> <p>技術能力讓我們能寫出程式，但產品思維和設計思考讓我們能寫出「對的」程式。</p> <hr/> <p><em>50 天寫作挑戰 Day 2</em></p>]]></content><author><name></name></author><category term="experience"/><category term="product-thinking"/><category term="design-thinking"/><category term="development"/><summary type="html"><![CDATA[10 年開發經驗讓我深刻體會到，擁有產品思維與設計思考能力，是讓程式碼從「能跑」到「好用」的關鍵轉折。]]></summary></entry><entry><title type="html">10 年軟體開發之路：我學到的 10 件事</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/10-years-of-software-development/" rel="alternate" type="text/html" title="10 年軟體開發之路：我學到的 10 件事"/><published>2025-01-13T10:00:00+00:00</published><updated>2025-01-13T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/10-years-of-software-development</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/10-years-of-software-development/"><![CDATA[<p>10 年，說長不長，說短不短。在這條軟體開發的路上，我學到了很多，也犯過不少錯誤。今天想分享 10 個最重要的教訓。</p> <h2 id="1-程式碼是寫給人看的">1. 程式碼是寫給人看的</h2> <p>程式碼的可讀性遠比聰明更重要。6 個月後，你可能會忘記自己寫了什麼。</p> <h2 id="2-技術債是會累積的">2. 技術債是會累積的</h2> <p>快速修復可以解決當下問題，但技術債會隨著時間累積，最終需要付出更大的代價。</p> <h2 id="3-溝通比技術更重要">3. 溝通比技術更重要</h2> <p>再好的技術，如果無法與團隊有效溝通，也無法發揮價值。</p> <h2 id="4-使用者體驗是核心">4. 使用者體驗是核心</h2> <p>功能再強大，如果使用者不會用或不想用，就沒有意義。</p> <h2 id="5-持續學習是必須的">5. 持續學習是必須的</h2> <p>技術變化太快，停止學習就等於被淘汰。</p> <h2 id="6-測試不是選項">6. 測試不是選項</h2> <p>寫測試不是浪費時間，而是節省時間。好的測試能讓重構更有信心。</p> <h2 id="7-簡單比複雜更難">7. 簡單比複雜更難</h2> <p>寫出複雜的程式不難，難的是寫出簡單而優雅的解決方案。</p> <h2 id="8-工具很重要但不是全部">8. 工具很重要，但不是全部</h2> <p>好的工具能提升效率，但更重要的是使用工具的人。</p> <h2 id="9-失敗是最好的老師">9. 失敗是最好的老師</h2> <p>每個錯誤都是一次學習機會，關鍵是要從中學到東西。</p> <h2 id="10-保持好奇心">10. 保持好奇心</h2> <p>對新技術、新方法保持好奇，但也要有判斷力，不是所有新東西都值得追。</p> <h2 id="結語">結語</h2> <p>10 年過去了，我還在學習。這條路沒有終點，只有不斷前進。</p> <hr/> <p><em>50 天寫作挑戰 Day 3</em></p>]]></content><author><name></name></author><category term="experience"/><category term="career"/><category term="experience"/><category term="lessons-learned"/><summary type="html"><![CDATA[回顧 10 年軟體規劃與設計經驗，分享我學到的最重要的 10 個教訓。]]></summary></entry><entry><title type="html">開發者也需要設計思考</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/design-thinking-for-developers/" rel="alternate" type="text/html" title="開發者也需要設計思考"/><published>2025-01-12T10:00:00+00:00</published><updated>2025-01-12T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/design-thinking-for-developers</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/design-thinking-for-developers/"><![CDATA[<p>很多人認為設計思考是設計師的事，但其實開發者同樣需要設計思考。</p> <h2 id="什麼是設計思考">什麼是設計思考？</h2> <p>設計思考是一套以人為本的解決問題方法論，包含五個階段：</p> <ol> <li><strong>同理心（Empathize）</strong>：理解使用者的需求</li> <li><strong>定義（Define）</strong>：釐清問題的本質</li> <li><strong>發想（Ideate）</strong>：探索各種可能的解決方案</li> <li><strong>原型（Prototype）</strong>：快速製作可測試的原型</li> <li><strong>測試（Test）</strong>：驗證並迭代</li> </ol> <h2 id="開發者如何應用設計思考">開發者如何應用設計思考？</h2> <h3 id="在需求階段">在需求階段</h3> <p>不要只問「要做什麼功能」，而要問「為什麼需要這個功能」、「使用者會怎麼使用」。</p> <h3 id="在設計階段">在設計階段</h3> <p>思考使用者的使用情境，而不只是技術實現。</p> <h3 id="在開發階段">在開發階段</h3> <p>寫程式時，考慮未來維護這份程式碼的人（可能是 6 個月後的自己）。</p> <h3 id="在測試階段">在測試階段</h3> <p>不只是測試功能是否正常，也要測試使用者體驗是否流暢。</p> <h2 id="實際案例">實際案例</h2> <p>最近在開發一個新功能時，我沒有直接開始寫程式，而是先：</p> <ol> <li>訪談了幾個目標使用者</li> <li>畫了簡單的使用流程圖</li> <li>做了紙本原型</li> <li>請使用者試用並收集回饋</li> </ol> <p>結果發現，原本想做的功能其實不是使用者真正需要的。這個過程雖然多花了一些時間，但避免了更大的浪費。</p> <h2 id="結語">結語</h2> <p>設計思考不是流程，而是一種思維方式。當我們開始以使用者為中心思考時，寫出來的程式就會不一樣。</p> <hr/> <p><em>50 天寫作挑戰 Day 4</em></p>]]></content><author><name></name></author><category term="methodology"/><category term="design-thinking"/><category term="development"/><category term="process"/><summary type="html"><![CDATA[設計思考不只是設計師的專利，開發者同樣可以從中獲益。分享如何將設計思考融入開發流程。]]></summary></entry><entry><title type="html">使用 Cursor 進行 AI 輔助開發的實際體驗</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/cursor-ai-coding-experience/" rel="alternate" type="text/html" title="使用 Cursor 進行 AI 輔助開發的實際體驗"/><published>2025-01-11T10:00:00+00:00</published><updated>2025-01-11T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/cursor-ai-coding-experience</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/cursor-ai-coding-experience/"><![CDATA[<p>Cursor 是我目前主要的開發 IDE，它整合了 AI 輔助編碼功能，讓開發體驗有了很大的改變。</p> <h2 id="為什麼選擇-cursor">為什麼選擇 Cursor？</h2> <ol> <li><strong>無縫整合</strong>：AI 功能直接整合在編輯器中，不需要切換視窗</li> <li><strong>上下文理解</strong>：能夠理解整個專案的結構和上下文</li> <li><strong>快速迭代</strong>：可以快速生成和修改程式碼</li> </ol> <h2 id="實際使用場景">實際使用場景</h2> <h3 id="1-快速生成樣板程式碼">1. 快速生成樣板程式碼</h3> <p>寫 API endpoint 時，Cursor 可以快速生成基本的 CRUD 操作程式碼，我只需要調整業務邏輯。</p> <h3 id="2-重構和優化">2. 重構和優化</h3> <p>當我需要重構一段程式碼時，Cursor 可以：</p> <ul> <li>建議更好的寫法</li> <li>自動重構</li> <li>保持功能不變</li> </ul> <h3 id="3-除錯和修復">3. 除錯和修復</h3> <p>遇到錯誤時，Cursor 可以：</p> <ul> <li>分析錯誤訊息</li> <li>提供修復建議</li> <li>解釋問題原因</li> </ul> <h2 id="使用技巧">使用技巧</h2> <ol> <li><strong>提供清楚的上下文</strong>：在註解中說明你的意圖，AI 會更準確</li> <li><strong>逐步迭代</strong>：不要一次要求太多，分步驟進行</li> <li><strong>驗證結果</strong>：AI 生成的程式碼要仔細檢查，特別是邊界情況</li> </ol> <h2 id="缺點和限制">缺點和限制</h2> <ol> <li><strong>成本</strong>：訂閱費用不低</li> <li><strong>依賴性</strong>：可能會過度依賴 AI，降低獨立思考能力</li> <li><strong>準確性</strong>：有時生成的程式碼需要大量調整</li> </ol> <h2 id="結語">結語</h2> <p>Cursor 是一個強大的工具，但工具只是輔助。最終還是要靠自己的判斷和經驗來寫出好的程式碼。</p> <hr/> <p><em>50 天寫作挑戰 Day 5</em></p>]]></content><author><name></name></author><category term="tools"/><category term="cursor"/><category term="ai-coding"/><category term="tools"/><summary type="html"><![CDATA[分享使用 Cursor 作為主要開發工具的實際體驗，包括優點、缺點和使用技巧。]]></summary></entry><entry><title type="html">Code Review 的最佳實踐：10 年經驗總結</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/code-review-best-practices/" rel="alternate" type="text/html" title="Code Review 的最佳實踐：10 年經驗總結"/><published>2025-01-10T10:00:00+00:00</published><updated>2025-01-10T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/code-review-best-practices</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/code-review-best-practices/"><![CDATA[<p>Code Review 是軟體開發中非常重要的一環，但要做好並不容易。這篇文章分享我 10 年經驗中學到的最佳實踐。</p> <h2 id="code-review-的目的">Code Review 的目的</h2> <p>Code Review 不只是找 bug，更重要的是：</p> <ol> <li><strong>知識分享</strong>：讓團隊成員了解彼此的程式碼</li> <li><strong>品質保證</strong>：確保程式碼符合團隊標準</li> <li><strong>學習成長</strong>：互相學習更好的寫法</li> <li><strong>風險控制</strong>：及早發現潛在問題</li> </ol> <h2 id="最佳實踐">最佳實踐</h2> <h3 id="對-reviewer-來說">對 Reviewer 來說</h3> <ol> <li><strong>保持友善</strong>：Code Review 是討論，不是批評</li> <li><strong>解釋原因</strong>：不只是說「這樣不好」，要說明為什麼</li> <li><strong>提出建議</strong>：如果可能，提供具體的改進方案</li> <li><strong>及時回覆</strong>：不要讓 PR 掛太久</li> <li><strong>肯定好的地方</strong>：不只是找問題，也要肯定做得好的地方</li> </ol> <h3 id="對-author-來說">對 Author 來說</h3> <ol> <li><strong>保持開放</strong>：把 Review 當作學習機會</li> <li><strong>解釋設計決策</strong>：在 PR 描述中說明為什麼這樣設計</li> <li><strong>小步提交</strong>：小的 PR 更容易 Review</li> <li><strong>回應評論</strong>：對每個評論都要回應，即使不認同也要說明原因</li> </ol> <h2 id="常見陷阱">常見陷阱</h2> <ol> <li><strong>過度關注風格</strong>：使用 linter 自動處理格式問題</li> <li><strong>個人偏好</strong>：區分「不喜歡」和「真的有問題」</li> <li><strong>拖延 Review</strong>：及時 Review 才能保持開發節奏</li> <li><strong>過度 Review</strong>：不是每個小問題都需要改</li> </ol> <h2 id="結語">結語</h2> <p>好的 Code Review 文化需要時間建立，但一旦建立起來，對團隊的幫助是巨大的。</p> <hr/> <p><em>50 天寫作挑戰 Day 6</em></p>]]></content><author><name></name></author><category term="methodology"/><category term="code-review"/><category term="best-practices"/><category term="team-collaboration"/><summary type="html"><![CDATA[分享 10 年開發經驗中，關於 Code Review 的最佳實踐和常見陷阱。]]></summary></entry><entry><title type="html">技術債管理：如何與技術債共存</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/technical-debt-management/" rel="alternate" type="text/html" title="技術債管理：如何與技術債共存"/><published>2025-01-09T10:00:00+00:00</published><updated>2025-01-09T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/technical-debt-management</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/technical-debt-management/"><![CDATA[<p>技術債是每個開發團隊都會遇到的問題。完全避免技術債幾乎不可能，關鍵是如何管理它。</p> <h2 id="什麼是技術債">什麼是技術債？</h2> <p>技術債是指為了快速交付功能，而採取的短期解決方案所累積的技術成本。就像金融債務一樣，技術債也需要償還，而且拖得越久，利息越高。</p> <h2 id="技術債的類型">技術債的類型</h2> <ol> <li><strong>程式碼品質</strong>：重複程式碼、過度複雜的邏輯</li> <li><strong>架構設計</strong>：不合理的架構決策</li> <li><strong>測試覆蓋</strong>：缺乏測試或測試品質不佳</li> <li><strong>文件缺失</strong>：缺乏文件或文件過時</li> <li><strong>依賴管理</strong>：使用過時的依賴或版本</li> </ol> <h2 id="如何管理技術債">如何管理技術債？</h2> <h3 id="1-識別和記錄">1. 識別和記錄</h3> <p>建立技術債清單，記錄：</p> <ul> <li>問題描述</li> <li>影響範圍</li> <li>優先級</li> <li>預估修復時間</li> </ul> <h3 id="2-定期償還">2. 定期償還</h3> <p>不要等到技術債累積到無法承受才處理。可以：</p> <ul> <li><strong>每週固定時間</strong>：例如每週五下午專門處理技術債</li> <li><strong>每個 Sprint</strong>：在每個 Sprint 中分配一定比例的時間</li> <li><strong>重構時機</strong>：在新增功能時，順便重構相關程式碼</li> </ul> <h3 id="3-預防新債">3. 預防新債</h3> <ul> <li><strong>Code Review</strong>：在 Review 時注意技術債的產生</li> <li><strong>技術標準</strong>：建立團隊的技術標準和最佳實踐</li> <li><strong>定期重構</strong>：不要等到問題嚴重才重構</li> </ul> <h2 id="何時償還技術債">何時償還技術債？</h2> <ol> <li><strong>影響開發效率時</strong>：當技術債開始拖慢開發速度</li> <li><strong>準備擴展功能時</strong>：在新增相關功能前，先清理技術債</li> <li><strong>有時間緩衝時</strong>：在專案不忙的時候處理</li> </ol> <h2 id="結語">結語</h2> <p>技術債不是敵人，而是需要管理的資源。關鍵是找到平衡點，既不過度追求完美，也不放任技術債累積。</p> <hr/> <p><em>50 天寫作挑戰 Day 7</em></p>]]></content><author><name></name></author><category term="methodology"/><category term="technical-debt"/><category term="code-quality"/><category term="maintenance"/><summary type="html"><![CDATA[技術債是軟體開發中不可避免的問題，分享如何有效管理和償還技術債。]]></summary></entry><entry><title type="html">開發者如何思考使用者體驗</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/user-experience-in-development/" rel="alternate" type="text/html" title="開發者如何思考使用者體驗"/><published>2025-01-08T10:00:00+00:00</published><updated>2025-01-08T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/user-experience-in-development</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/user-experience-in-development/"><![CDATA[<p>作為開發者，我們很容易陷入技術實現的細節中，而忽略了使用者的感受。但好的使用者體驗，往往來自開發階段的思考。</p> <h2 id="從功能到體驗">從功能到體驗</h2> <p>傳統的開發流程是：</p> <ol> <li>收到需求</li> <li>設計資料庫</li> <li>寫 API</li> <li>寫前端</li> <li>測試功能</li> <li>上線</li> </ol> <p>但這樣的流程，往往會產生「功能都有了，但不好用」的產品。</p> <h2 id="開發者如何思考-ux">開發者如何思考 UX？</h2> <h3 id="1-從使用者角度思考">1. 從使用者角度思考</h3> <p>寫程式前，先問自己：</p> <ul> <li>使用者會在哪裡使用這個功能？</li> <li>使用者的目標是什麼？</li> <li>使用者會遇到什麼問題？</li> </ul> <h3 id="2-考慮使用情境">2. 考慮使用情境</h3> <p>不只是「功能能不能用」，還要考慮：</p> <ul> <li><strong>載入速度</strong>：使用者願意等多久？</li> <li><strong>錯誤處理</strong>：出錯時使用者會看到什麼？</li> <li><strong>空狀態</strong>：沒有資料時畫面長什麼樣？</li> <li><strong>邊界情況</strong>：極端情況下的體驗如何？</li> </ul> <h3 id="3-提供即時回饋">3. 提供即時回饋</h3> <p>使用者的每個操作都應該有回饋：</p> <ul> <li>按鈕點擊：顯示 loading 狀態</li> <li>表單提交：顯示成功或錯誤訊息</li> <li>資料載入：顯示進度或骨架屏</li> </ul> <h2 id="實際案例">實際案例</h2> <p>最近在開發一個搜尋功能時，我沒有只考慮「如何實現搜尋」，而是思考：</p> <ol> <li><strong>輸入體驗</strong>：是否需要自動完成？是否需要搜尋建議？</li> <li><strong>結果呈現</strong>：如何讓使用者快速找到想要的結果？</li> <li><strong>無結果處理</strong>：沒有結果時，如何引導使用者？</li> <li><strong>效能優化</strong>：如何避免每次輸入都發送請求？</li> </ol> <p>這些思考讓最終的搜尋功能不只是「能用」，而是「好用」。</p> <h2 id="結語">結語</h2> <p>使用者體驗不是設計師的專利，開發者同樣可以從 UX 角度思考。當我們開始關注使用者的感受時，寫出來的程式就會不一樣。</p> <hr/> <p><em>50 天寫作挑戰 Day 8</em></p>]]></content><author><name></name></author><category term="methodology"/><category term="ux"/><category term="user-experience"/><category term="development"/><summary type="html"><![CDATA[分享開發者如何從技術實現轉向使用者體驗思考，以及實際的實踐方法。]]></summary></entry><entry><title type="html">測試策略：開發者如何寫出有效的測試</title><link href="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/testing-strategy-for-developers/" rel="alternate" type="text/html" title="測試策略：開發者如何寫出有效的測試"/><published>2025-01-07T10:00:00+00:00</published><updated>2025-01-07T10:00:00+00:00</updated><id>https://otoitsuki.github.io/blog_videcoding50days/blog/2025/testing-strategy-for-developers</id><content type="html" xml:base="https://otoitsuki.github.io/blog_videcoding50days/blog/2025/testing-strategy-for-developers/"><![CDATA[<p>測試是軟體開發中非常重要的一環，但很多開發者對測試有誤解。這篇文章分享我對測試的理解和實踐。</p> <h2 id="為什麼要寫測試">為什麼要寫測試？</h2> <ol> <li><strong>信心</strong>：有測試的程式碼，重構時更有信心</li> <li><strong>文件</strong>：測試就是最好的文件，說明程式碼應該如何運作</li> <li><strong>設計</strong>：寫測試的過程，會強迫你思考設計</li> <li><strong>回歸</strong>：防止新功能破壞舊功能</li> </ol> <h2 id="測試金字塔">測試金字塔</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        /\
       /  \      E2E Tests (少)
      /____\
     /      \    Integration Tests (中)
    /________\
   /          \  Unit Tests (多)
  /____________\
</code></pre></div></div> <ul> <li><strong>Unit Tests</strong>：測試單一函數或類別，應該最多</li> <li><strong>Integration Tests</strong>：測試多個組件的整合</li> <li><strong>E2E Tests</strong>：測試完整的使用流程，應該最少</li> </ul> <h2 id="如何寫好測試">如何寫好測試？</h2> <h3 id="1-測試行為不是實現">1. 測試行為，不是實現</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ❌ 不好的測試：測試實現細節
</span><span class="k">def</span> <span class="nf">test_calculate_total</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">calculate_total</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">result</span><span class="p">.</span><span class="n">_sum</span> <span class="o">==</span> <span class="mi">6</span>  <span class="c1"># 測試內部變數
</span>
<span class="c1"># ✅ 好的測試：測試行為
</span><span class="k">def</span> <span class="nf">test_calculate_total</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">calculate_total</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">6</span>  <span class="c1"># 測試公開介面
</span></code></pre></div></div> <h3 id="2-一個測試一個概念">2. 一個測試一個概念</h3> <p>不要在一個測試中測試太多東西，每個測試應該只驗證一個概念。</p> <h3 id="3-測試邊界情況">3. 測試邊界情況</h3> <p>不只是測試「正常情況」，也要測試：</p> <ul> <li>空值</li> <li>極值</li> <li>錯誤輸入</li> <li>邊界值</li> </ul> <h3 id="4-測試名稱要清楚">4. 測試名稱要清楚</h3> <p>測試名稱應該清楚說明測試的內容：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ❌ 不清楚
</span><span class="k">def</span> <span class="nf">test_function</span><span class="p">():</span>
    <span class="bp">...</span>

<span class="c1"># ✅ 清楚
</span><span class="k">def</span> <span class="nf">test_calculate_total_returns_sum_of_items</span><span class="p">():</span>
    <span class="bp">...</span>
</code></pre></div></div> <h2 id="tdd-的實踐">TDD 的實踐</h2> <p>TDD (Test-Driven Development) 的流程：</p> <ol> <li><strong>Red</strong>：寫一個會失敗的測試</li> <li><strong>Green</strong>：寫最少的程式碼讓測試通過</li> <li><strong>Refactor</strong>：重構程式碼，保持測試通過</li> </ol> <p>TDD 不是萬能的，但在某些情況下很有用，特別是當需求很明確時。</p> <h2 id="結語">結語</h2> <p>測試不是負擔，而是投資。好的測試能讓開發更快、更安全、更有信心。</p> <hr/> <p><em>50 天寫作挑戰 Day 9</em></p>]]></content><author><name></name></author><category term="methodology"/><category term="testing"/><category term="tdd"/><category term="quality-assurance"/><summary type="html"><![CDATA[分享 10 年開發經驗中，關於測試策略和測試寫法的心得。]]></summary></entry></feed>